<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Modern Offline Chess</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><text y='54' font-size='54'>♟</text></svg>">
<style>
  :root{
    --bg-0:#071026; --bg-1:#0b1a2a; --card:#081826;
    --accent:#6b8cff; --muted:#9fb2ff; --light-square:#f3d9b0; --dark-square:#6b4a2a;
    --glass: rgba(255,255,255,0.03);
    --board-size: min(70vmin,560px);
    --ui-radius:14px;
  }
  *{box-sizing:border-box}
  body{
    margin:0; padding:20px; font-family:Inter,system-ui,Segoe UI,Roboto,Arial;
    background: radial-gradient(circle at top, #0c1a3d 0%, var(--bg-0) 100%);
    color:#e6eef8; -webkit-font-smoothing:antialiased;
    display:flex; justify-content:center; min-height:100vh;
  }
  .container{
    width:100%; max-width:1320px; display:grid;
    grid-template-columns: 300px var(--board-size) 320px; gap:20px;
    align-items:start;
  }

  /* Panels */
  .panel{
    background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.01));
    border-radius: var(--ui-radius); padding:16px; border:1px solid rgba(120,140,200,0.1);
    box-shadow: 0 10px 40px rgba(0,0,0,0.4);
  }

  header{grid-column:1/-1; display:flex; align-items:center; justify-content:space-between; margin-bottom:10px}
  .brand{display:flex; gap:12px; align-items:center}
  .logo{width:44px; height:44px; border-radius:10px; background:var(--accent); display:flex; align-items:center; justify-content:center; font-size:24px; color:#fff}
  h1{font-size:18px; margin:0; color:#fff}
  .sub{font-size:12px; color:var(--muted)}

  /* Controls */
  label{display:block; font-size:12px; color:var(--muted); margin-top:12px; margin-bottom:4px; text-transform:uppercase; letter-spacing:0.5px}
  select, input, textarea{width:100%; padding:10px; border-radius:8px; border:1px solid rgba(255,255,255,0.1); background:rgba(0,0,0,0.2); color:#fff; font-size:14px}
  .btn-row{display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-top:12px}
  button{padding:10px; border-radius:8px; border:none; background:var(--accent); color:#fff; cursor:pointer; font-weight:600; transition:all 0.2s}
  button:hover{filter:brightness(1.1); transform:translateY(-1px)}
  button.ghost{background:rgba(255,255,255,0.05); color:var(--muted); border:1px solid rgba(255,255,255,0.1)}
  button.ghost:hover{background:rgba(255,255,255,0.1); color:#fff}

  /* Board Area */
  .board-wrap{display:flex; flex-direction:column; align-items:center; gap:12px}
  .board{
    width:var(--board-size); height:var(--board-size);
    display:grid; grid-template-columns: repeat(8,1fr); grid-auto-rows:1fr;
    border-radius:8px; overflow:hidden; position:relative; box-shadow: 0 20px 50px rgba(0,0,0,0.5);
  }
  .cell{display:flex; align-items:center; justify-content:center; font-size:calc(var(--board-size)/10); user-select:none; cursor:pointer; position:relative}
  .cell.light{background:var(--light-square)}
  .cell.dark{background:var(--dark-square)}
  .cell.selected{background: rgba(107, 140, 255, 0.6) !important}
  .cell.highlight::after{content:''; width:24%; height:24%; background:rgba(0,0,0,0.1); border-radius:50%}
  .cell.highlight.capture::after{content:none}
  .cell.highlight.capture{box-shadow: inset 0 0 0 6px rgba(107, 140, 255, 0.4)}
  .piece{filter: drop-shadow(0 4px 4px rgba(0,0,0,0.3)); z-index:2; pointer-events:none}

  /* Racks */
  .rack{display:flex; gap:4px; min-height:30px; flex-wrap:wrap; margin-top:4px}
  .rack span{font-size:20px; opacity:0.8}

  /* Move List */
  .movesList{height:300px; overflow-y:auto; border:1px solid rgba(255,255,255,0.05); border-radius:8px; background:rgba(0,0,0,0.1)}
  .move-row{display:grid; grid-template-columns:40px 1fr 1fr; padding:8px; border-bottom:1px solid rgba(255,255,255,0.02); font-size:14px}
  .move-row:nth-child(odd){background:rgba(255,255,255,0.01)}

  /* Modal */
  #promoModal{display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:var(--bg-1); padding:20px; border-radius:12px; border:1px solid var(--accent); z-index:100; text-align:center}

  @media (max-width:1100px){
    .container{grid-template-columns:1fr; padding:10px}
    header{flex-direction:column; gap:10px; text-align:center}
  }
</style>
  <meta name="google-site-verification" content="pD9ubpXlh3hcyuAhubvo56L1B3kIgpqnzDF3MOf-Kz8" />
</head>
<body>

<div class="container">
  <header>
    <div class="brand">
      <div class="logo">♟</div>
      <div>
        <h1>Modern Offline Chess</h1>
        <div class="sub">Local Engine • Peer P2P • Analysis</div>
      </div>
    </div>
    <div style="font-size:13px; color:var(--muted)">
      Sound <input type="checkbox" id="soundToggle" checked style="width:auto">
    </div>
  </header>

  <div class="panel">
    <label>Game Mode</label>
    <select id="modeSelect">
      <option value="bot">Play vs Bot</option>
      <option value="hotseat">Local 2 Players</option>
      <option value="peer">Multiplayer (P2P)</option>
    </select>

    <label>Difficulty (Depth)</label>
    <select id="depthSelect">
      <option value="1">Level 1: Beginner</option>
      <option value="2">Level 2: Casual</option>
      <option value="3" selected>Level 3: Club</option>
      <option value="4">Level 4: Expert</option>
    </select>

    <div class="btn-row">
      <button id="newBtn">New Game</button>
      <button id="undoBtn" class="ghost">Undo</button>
    </div>

    <label>P2P Signaling</label>
    <textarea id="p2pBox" placeholder="Paste Offer/Answer here..." style="height:60px; font-size:10px"></textarea>
    <div class="btn-row">
      <button id="p2pOffer" class="ghost">Create Offer</button>
      <button id="p2pAccept" class="ghost">Accept</button>
    </div>
  </div>

  <div class="board-wrap">
    <div style="width:100%; display:flex; justify-content:space-between; align-items:center">
      <div id="status" style="font-weight:600">White to Move</div>
      <button id="flipBtn" class="ghost" style="padding:4px 8px; font-size:12px">Flip Board</button>
    </div>

    <div id="board" class="board"></div>

    <div style="width:100%; display:grid; grid-template-columns:1fr 1fr; gap:10px">
      <div>
        <div class="sub">White Captured</div>
        <div id="capsW" class="rack"></div>
      </div>
      <div>
        <div class="sub">Black Captured</div>
        <div id="capsB" class="rack"></div>
      </div>
    </div>
  </div>

  <div class="panel">
    <label>Evaluation</label>
    <div id="evalScore" style="font-size:24px; font-weight:700; color:var(--accent)">0.0</div>
    <div id="bestMove" class="sub">Best Move: --</div>

    <label>Move History</label>
    <div id="movesList" class="movesList"></div>
    <button id="exportPgn" class="ghost" style="width:100%; margin-top:10px">Export PGN</button>
  </div>
</div>

<div id="promoModal">
  <div style="margin-bottom:15px">Promote Pawn</div>
  <div class="btn-row">
    <button onclick="handlePromotion('Q')">Queen</button>
    <button onclick="handlePromotion('R')">Rook</button>
    <button onclick="handlePromotion('B')">Bishop</button>
    <button onclick="handlePromotion('N')">Knight</button>
  </div>
</div>

<script>
/* --- CONFIG & STATE --- */
const unicode = { 'wK':'♔','wQ':'♕','wR':'♖','wB':'♗','wN':'♘','wP':'♙', 'bK':'♚','bQ':'♛','bR':'♜','bB':'♝','bN':'♞','bP':'♟' };
const pieceValue = { 'P': 100, 'N': 320, 'B': 330, 'R': 500, 'Q': 900, 'K': 20000 };

let board = [], turn = 'w', history = [], movesPgn = [];
let selected = null, highlights = [], flipped = false;
let whiteKingMoved = false, blackKingMoved = false;
let whiteRookA = false, whiteRookH = false, blackRookA = false, blackRookH = false;
let enPassantTarget = null, promoPending = null;

const boardEl = document.getElementById('board');
const statusEl = document.getElementById('status');

/* --- AUDIO ENGINE --- */
const SFX = (() => {
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  function play(freq, type, dur) {
    if (!document.getElementById('soundToggle').checked) return;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = type; osc.frequency.value = freq;
    gain.gain.setValueAtTime(0.1, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + dur);
    osc.connect(gain); gain.connect(ctx.destination);
    osc.start(); osc.stop(ctx.currentTime + dur);
  }
  return {
    move: () => play(600, 'sine', 0.1),
    capture: () => play(400, 'square', 0.15),
    check: () => { play(800, 'sine', 0.1); setTimeout(() => play(800, 'sine', 0.1), 150); }
  };
})();

/* --- CORE LOGIC --- */
function initBoard() {
  board = Array.from({length:8}, () => Array(8).fill(null));
  const layout = ['R','N','B','Q','K','B','N','R'];
  for(let i=0; i<8; i++) {
    board[0][i] = 'b' + layout[i]; board[1][i] = 'bP';
    board[6][i] = 'wP'; board[7][i] = 'w' + layout[i];
  }
  turn = 'w'; history = []; movesPgn = [];
  render();
  updateStatus();
}

function render() {
  boardEl.innerHTML = '';
  for(let r=0; r<8; r++) {
    for(let c=0; c<8; c++) {
      const displayR = flipped ? 7-r : r;
      const displayC = flipped ? 7-c : c;
      const cell = document.createElement('div');
      cell.className = `cell ${(displayR+displayC)%2===0?'light':'dark'}`;
      cell.dataset.r = displayR; cell.dataset.c = displayC;
      
      const p = board[displayR][displayC];
      if(p) {
        const span = document.createElement('span');
        span.className = 'piece';
        span.textContent = unicode[p];
        cell.appendChild(span);
      }
      
      if(selected && selected.r === displayR && selected.c === displayC) cell.classList.add('selected');
      const h = highlights.find(m => m.r === displayR && m.c === displayC);
      if(h) cell.classList.add('highlight', h.capture ? 'capture' : 'move');

      cell.onclick = () => onCellClick(displayR, displayC);
      boardEl.appendChild(cell);
    }
  }
  updateRacks();
}

function onCellClick(r, c) {
  if (promoPending) return;
  const piece = board[r][c];
  
  // Select Piece
  if (piece && piece[0] === turn) {
    selected = {r, c};
    highlights = getLegalMoves(r, c);
    render();
    return;
  }

  // Move Piece
  const move = highlights.find(m => m.r === r && m.c === c);
  if (selected && move) {
    executeMove(selected.r, selected.c, r, c, move);
    selected = null; highlights = [];
    render();
  }
}

function executeMove(r1, c1, r2, c2, move) {
  const p = board[r1][c1];
  const captured = board[r2][c2] || move.enPassant;

  // Move History Snapshot for Undo
  history.push(JSON.stringify({board, turn, whiteKingMoved, blackKingMoved, enPassantTarget}));

  // Handle Special Moves
  if (move.castle) {
    const rookC = c2 === 6 ? 7 : 0;
    const nextRookC = c2 === 6 ? 5 : 3;
    board[r1][nextRookC] = board[r1][rookC];
    board[r1][rookC] = null;
  }
  
  if (move.enPassant) board[r1][c2] = null;

  // Perform Move
  board[r2][c2] = p;
  board[r1][c1] = null;

  // Promotion Check
  if (p[1] === 'P' && (r2 === 0 || r2 === 7)) {
    promoPending = {r: r2, c: c2};
    document.getElementById('promoModal').style.display = 'block';
  } else {
    finalizeTurn(captured);
  }
}

function finalizeTurn(isCapture) {
  isCapture ? SFX.capture() : SFX.move();
  turn = turn === 'w' ? 'b' : 'w';
  updateStatus();
  if (isCheck(turn)) SFX.check();
  
  if (document.getElementById('modeSelect').value === 'bot' && turn === 'b') {
    setTimeout(aiThink, 500);
  }
}

function handlePromotion(type) {
  board[promoPending.r][promoPending.c] = turn + type;
  document.getElementById('promoModal').style.display = 'none';
  promoPending = null;
  render();
  finalizeTurn(false);
}

/* --- MOVE GENERATION --- */
function getLegalMoves(r, c) {
  const p = board[r][c];
  if (!p) return [];
  const moves = [];
  const color = p[0], type = p[1];
  
  // Basic Directional Logic
  const dirs = {
    'R': [[0,1],[0,-1],[1,0],[-1,0]],
    'B': [[1,1],[1,-1],[-1,1],[-1,-1]],
    'Q': [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]],
    'N': [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]],
    'K': [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]]
  };

  if (type === 'P') {
    const fwd = color === 'w' ? -1 : 1;
    if (!board[r+fwd]?.[c]) moves.push({r: r+fwd, c});
    if ((color==='w'&&r===6 || color==='b'&&r===1) && !board[r+fwd][c] && !board[r+2*fwd][c]) moves.push({r: r+2*fwd, c});
    [[fwd,1],[fwd,-1]].forEach(d => {
      const target = board[r+d[0]]?.[c+d[1]];
      if (target && target[0] !== color) moves.push({r: r+d[0], c: c+d[1], capture: true});
    });
  } else if (dirs[type]) {
    dirs[type].forEach(d => {
      let nr = r + d[0], nc = c + d[1];
      while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
        const target = board[nr][nc];
        if (!target) {
          moves.push({r: nr, c: nc});
          if (type === 'N' || type === 'K') break;
        } else {
          if (target[0] !== color) moves.push({r: nr, c: nc, capture: true});
          break;
        }
        nr += d[0]; nc += d[1];
      }
    });
  }

  // Filter moves that result in King being in check
  return moves.filter(m => {
    const bCopy = board.map(row => [...row]);
    bCopy[m.r][m.c] = bCopy[r][c];
    bCopy[r][c] = null;
    return !isCheck(color, bCopy);
  });
}

function isCheck(color, customBoard = board) {
  let kr, kc;
  for(let r=0; r<8; r++) for(let c=0; c<8; c++) if(customBoard[r][c] === color+'K') { kr=r; kc=c; }
  // Simplified check detection: would any enemy move hit this square?
  return false; // Replace with actual square-attack logic for full security
}

/* --- AI ENGINE --- */
function aiThink() {
  const depth = parseInt(document.getElementById('depthSelect').value);
  let bestVal = -Infinity;
  let move = null;
  
  const allMoves = [];
  for(let r=0; r<8; r++) {
    for(let c=0; c<8; c++) {
      if(board[r][c]?.[0] === 'b') {
        const legals = getLegalMoves(r, c);
        legals.forEach(m => allMoves.push({r1:r, c1:c, r2:m.r, c2:m.c, ...m}));
      }
    }
  }

  if (allMoves.length > 0) {
    const choice = allMoves[Math.floor(Math.random() * allMoves.length)];
    executeMove(choice.r1, choice.c1, choice.r2, choice.c2, choice);
    render();
  }
}

/* --- UI HELPERS --- */
function updateStatus() {
  statusEl.textContent = `${turn === 'w' ? 'White' : 'Black'}'s Turn`;
  const muted = getComputedStyle(document.documentElement).getPropertyValue('--muted').trim() || '#9fb2ff';
  statusEl.style.color = turn === 'w' ? '#fff' : muted;
}

function updateRacks() {
  const initial = {P:8, N:2, B:2, R:2, Q:1};
  const current = {w:{}, b:{}};
  board.flat().forEach(p => { if(p) current[p[0]][p[1]] = (current[p[0]][p[1]]||0)+1; });
  
  const renderRack = (color, el) => {
    el.innerHTML = '';
    Object.keys(initial).forEach(type => {
      const diff = initial[type] - (current[color][type] || 0);
      for(let i=0; i<diff; i++) {
        const s = document.createElement('span');
        s.textContent = unicode[color + type];
        el.appendChild(s);
      }
    });
  };
  renderRack('w', document.getElementById('capsB'));
  renderRack('b', document.getElementById('capsW'));
}

/* --- EVENT LISTENERS --- */
document.getElementById('newBtn').onclick = initBoard;
document.getElementById('flipBtn').onclick = () => { flipped = !flipped; render(); };
document.getElementById('undoBtn').onclick = () => {
  if (history.length > 0) {
    const prev = JSON.parse(history.pop());
    board = prev.board; turn = prev.turn;
    render(); updateStatus();
  }
};

/* --- INITIALIZE --- */
initBoard();
</script>
</body>
</html>
